{"version":3,"file":"tonal_palette.js","sourceRoot":"","sources":["tonal_palette.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Hct} from '../hct/hct.js';\n\n/**\n *  A convenience class for retrieving colors that are constant in hue and\n *  chroma, but vary in tone.\n */\nexport class TonalPalette {\n  private readonly cache = new Map<number, number>();\n\n  /**\n   * @param argb ARGB representation of a color\n   * @return Tones matching that color's hue and chroma.\n   */\n  static fromInt(argb: number): TonalPalette {\n    const hct = Hct.fromInt(argb);\n    return TonalPalette.fromHct(hct);\n  }\n\n  /**\n   * @param hct Hct\n   * @return Tones matching that color's hue and chroma.\n   */\n  static fromHct(hct: Hct) {\n    return new TonalPalette(hct.hue, hct.chroma, hct);\n  }\n\n  /**\n   * @param hue HCT hue\n   * @param chroma HCT chroma\n   * @return Tones matching hue and chroma.\n   */\n  static fromHueAndChroma(hue: number, chroma: number): TonalPalette {\n    const keyColor = new KeyColor(hue, chroma).create();\n    return new TonalPalette(hue, chroma, keyColor);\n  }\n\n  private constructor(readonly hue: number, readonly chroma: number, readonly keyColor: Hct) {}\n\n  /**\n   * @param tone HCT tone, measured from 0 to 100.\n   * @return ARGB representation of a color with that tone.\n   */\n  tone(tone: number): number {\n    let argb = this.cache.get(tone);\n    if (argb === undefined) {\n      argb = Hct.from(this.hue, this.chroma, tone).toInt();\n      this.cache.set(tone, argb);\n    }\n    return argb;\n  }\n\n  /**\n   * @param tone HCT tone.\n   * @return HCT representation of a color with that tone.\n   */\n  getHct(tone: number): Hct {\n    return Hct.fromInt(this.tone(tone));\n  }\n}\n\n/**\n * Key color is a color that represents the hue and chroma of a tonal palette\n */\nclass KeyColor {\n  // Cache that maps tone to max chroma to avoid duplicated HCT calculation.\n  private readonly chromaCache = new Map<number, number>();\n  private readonly maxChromaValue = 200.0;\n\n  constructor(readonly hue: number, readonly requestedChroma: number) {}\n\n  /**\n   * Creates a key color from a [hue] and a [chroma].\n   * The key color is the first tone, starting from T50, matching the given hue\n   * and chroma.\n   *\n   * @return Key color [Hct]\n   */\n  create(): Hct {\n    // Pivot around T50 because T50 has the most chroma available, on\n    // average. Thus it is most likely to have a direct answer.\n    const pivotTone = 50;\n    const toneStepSize = 1;\n    // Epsilon to accept values slightly higher than the requested chroma.\n    const epsilon = 0.01;\n\n    // Binary search to find the tone that can provide a chroma that is closest\n    // to the requested chroma.\n    let lowerTone = 0;\n    let upperTone = 100;\n    while (lowerTone < upperTone) {\n      const midTone = Math.floor((lowerTone + upperTone) / 2);\n      const isAscending =\n          this.maxChroma(midTone) < this.maxChroma(midTone + toneStepSize);\n      const sufficientChroma =\n          this.maxChroma(midTone) >= this.requestedChroma - epsilon;\n\n      if (sufficientChroma) {\n        // Either range [lowerTone, midTone] or [midTone, upperTone] has\n        // the answer, so search in the range that is closer the pivot tone.\n        if (Math.abs(lowerTone - pivotTone) < Math.abs(upperTone - pivotTone)) {\n          upperTone = midTone;\n        } else {\n          if (lowerTone === midTone) {\n            return Hct.from(this.hue, this.requestedChroma, lowerTone);\n          }\n          lowerTone = midTone;\n        }\n      } else {\n        // As there is no sufficient chroma in the midTone, follow the direction\n        // to the chroma peak.\n        if (isAscending) {\n          lowerTone = midTone + toneStepSize;\n        } else {\n          // Keep midTone for potential chroma peak.\n          upperTone = midTone;\n        }\n      }\n    }\n\n    return Hct.from(this.hue, this.requestedChroma, lowerTone);\n  }\n\n  // Find the maximum chroma for a given tone\n  private maxChroma(tone: number): number {\n    if (this.chromaCache.has(tone)) {\n      return this.chromaCache.get(tone)!;\n    }\n    const chroma = Hct.from(this.hue, this.maxChromaValue, tone).chroma;\n    this.chromaCache.set(tone, chroma);\n    return chroma;\n  }\n}\n"]}